/**
 * Tenancy Validation Vulnerability Test
 * Tests the requireOrgScopedAdmin middleware for improper multi-tenancy validation
 * 
 * VULNERABILITY: Middleware only validates req.query.organizationId, but many endpoints
 * use organizationId from req.body, req.params, or CSV content without validation.
 * 
 * Run against staging environment with two admin accounts from different organizations.
 */

const fs = require('fs');

// ============================================================================
// Configuration
// ============================================================================

const STAGING_URL = process.env.STAGING_URL || process.env.API_URL || 'https://feedbackflow-backend-staging.onrender.com';

// ANSI color codes for terminal output
const COLORS = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

// ============================================================================
// Helper Functions
// ============================================================================

function colorize(text, color) {
  return `${COLORS[color] || ''}${text}${COLORS.reset}`;
}

function log(message, color = null) {
  console.log(color ? colorize(message, color) : message);
}

function logSection(title) {
  console.log('\n' + '='.repeat(80));
  log(title, 'bright');
  console.log('='.repeat(80));
}

function logTest(number, total, name) {
  console.log('\n' + '-'.repeat(80));
  log(`[${number}/${total}] ${name}`, 'cyan');
  console.log('-'.repeat(80));
}

async function makeRequest(url, options = {}) {
  try {
    const response = await fetch(url, options);
    const contentType = response.headers.get('content-type');
    
    let data;
    if (contentType && contentType.includes('application/json')) {
      data = await response.json();
    } else {
      data = await response.text();
    }
    
    return {
      status: response.status,
      statusText: response.statusText,
      ok: response.ok,
      data,
      headers: Object.fromEntries(response.headers.entries())
    };
  } catch (error) {
    return {
      status: 0,
      statusText: 'Network Error',
      ok: false,
      error: error.message,
      data: null
    };
  }
}

async function validateHealth() {
  log('\nüîç Checking backend health...', 'blue');
  const response = await makeRequest(`${STAGING_URL}/api/v1/health`);
  
  if (!response.ok) {
    throw new Error(`Backend health check failed: ${response.status} ${response.statusText}`);
  }
  
  log(`‚úÖ Backend is healthy (${response.data.database})`, 'green');
  return response.data;
}

async function validateToken(token, label) {
  log(`\nüîç Validating ${label}...`, 'blue');
  
  // Try to fetch organizations with this token
  const response = await makeRequest(`${STAGING_URL}/api/v1/admin/organizations`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  });
  
  if (!response.ok) {
    throw new Error(`${label} validation failed: ${response.status} ${response.statusText}`);
  }
  
  const orgs = response.data?.data || [];
  log(`‚úÖ ${label} valid (has access to ${orgs.length} org(s))`, 'green');
  
  return { valid: true, organizations: orgs };
}

async function getOrganizationDetails(token, orgId) {
  const response = await makeRequest(`${STAGING_URL}/api/v1/admin/organizations/${orgId}`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  });
  
  return response;
}

async function getUsersByOrg(token, orgId) {
  const response = await makeRequest(`${STAGING_URL}/api/v1/admin/users?organizationId=${orgId}&limit=5`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  });
  
  return response;
}

function generateHierarchyCSV(orgName, orgSlug, relationships) {
  const lines = ['organization_name,organization_slug,employee_email,manager_email'];
  
  relationships.forEach(rel => {
    lines.push(`${orgName},${orgSlug},${rel.employee},${rel.manager}`);
  });
  
  return lines.join('\n');
}

// ============================================================================
// Test Cases
// ============================================================================

async function test1_HierarchyCSVUpload(config, results) {
  const testName = 'Hierarchy CSV Upload Cross-Organization Attack';
  logTest(1, 5, testName);
  
  log('\nüìã Description:', 'yellow');
  log('  Admin A attempts to upload hierarchy CSV containing Org B\'s data.');
  log('  CSV specifies organization by name/slug in each row.');
  log('  Middleware checks req.query.organizationId (not present).');
  log('  Endpoint uses organizationId from CSV without validation.');
  
  const csvContent = generateHierarchyCSV(
    config.adminBOrgName,
    config.adminBOrgSlug,
    [
      { employee: 'victim@orgb.com', manager: 'manager@orgb.com' }
    ]
  );
  
  log('\nüì§ Sending malicious CSV:', 'blue');
  log(`  Organization: ${config.adminBOrgName} (${config.adminBOrgSlug})`, 'blue');
  log(`  Token: Admin A (authorized for Org A only)`, 'blue');
  
  const response = await makeRequest(`${STAGING_URL}/api/v1/hierarchy/bulk/csv`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${config.adminAToken}`,
      'Content-Type': 'text/csv'
    },
    body: csvContent
  });
  
  log(`\nüì• Response: ${response.status} ${response.statusText}`, 'blue');
  log(`Data: ${JSON.stringify(response.data, null, 2)}`, 'blue');
  
  // Vulnerability check: Should get 403, but currently succeeds or processes
  const isVulnerable = response.status === 200 || 
                       (response.data?.success === true) ||
                       (response.data?.data?.created > 0);
  
  const result = {
    testName,
    endpoint: 'POST /api/v1/hierarchy/bulk/csv',
    attack: 'Admin A uploads hierarchy for Org B via CSV',
    expectedBehavior: '403 Forbidden - organizationId from CSV should be validated',
    actualStatus: response.status,
    vulnerable: isVulnerable,
    severity: 'CRITICAL',
    response: response.data
  };
  
  if (isVulnerable) {
    log('\n‚ö†Ô∏è  VULNERABILITY CONFIRMED ‚ö†Ô∏è', 'red');
    log('  Admin A can create hierarchy relationships in Org B!', 'red');
    log('  The organizationId from CSV is not validated against effectiveOrganizationId.', 'red');
  } else {
    log('\n‚úÖ Protected - Request was blocked', 'green');
  }
  
  results.push(result);
  return result;
}

async function test2_OrganizationAccess(config, results) {
  const testName = 'Organization Details Access (Path Parameter)';
  logTest(2, 5, testName);
  
  log('\nüìã Description:', 'yellow');
  log('  Admin A attempts to read Org B\'s details via path parameter.');
  log('  Middleware checks req.query.organizationId (not present).');
  log('  Controller uses req.params.id without validation.');
  
  log('\nüì§ Requesting Org B details with Admin A token:', 'blue');
  log(`  Organization ID: ${config.adminBOrgId}`, 'blue');
  log(`  Token: Admin A (authorized for Org A only)`, 'blue');
  
  const response = await getOrganizationDetails(config.adminAToken, config.adminBOrgId);
  
  log(`\nüì• Response: ${response.status} ${response.statusText}`, 'blue');
  log(`Data: ${JSON.stringify(response.data, null, 2)}`, 'blue');
  
  // Vulnerability check: Should get 403, but currently returns Org B's data
  const isVulnerable = response.status === 200 && 
                       (response.data?.id === config.adminBOrgId || 
                        response.data?.organization_id === config.adminBOrgId);
  
  const result = {
    testName,
    endpoint: 'GET /api/v1/admin/organizations/:id',
    attack: 'Admin A reads Org B details via path parameter',
    expectedBehavior: '403 Forbidden - req.params.id should be validated',
    actualStatus: response.status,
    vulnerable: isVulnerable,
    severity: 'HIGH',
    response: response.data
  };
  
  if (isVulnerable) {
    log('\n‚ö†Ô∏è  VULNERABILITY CONFIRMED ‚ö†Ô∏è', 'red');
    log('  Admin A can read Org B\'s details!', 'red');
    log('  Path parameter is not validated against effectiveOrganizationId.', 'red');
    
    if (response.data?.name) {
      log(`  Leaked info: Organization name = "${response.data.name}"`, 'red');
    }
  } else {
    log('\n‚úÖ Protected - Request was blocked or returned empty', 'green');
  }
  
  results.push(result);
  return result;
}

async function test3_OrganizationUpdate(config, results) {
  const testName = 'Organization Update (Path Parameter)';
  logTest(3, 5, testName);
  
  log('\nüìã Description:', 'yellow');
  log('  Admin A attempts to update Org B\'s settings via path parameter.');
  log('  Middleware checks req.query.organizationId (not present).');
  log('  Controller uses req.params.id without validation.');
  
  // Use a non-destructive update that's easily reversible
  const maliciousUpdate = {
    description: `HACKED BY ADMIN A AT ${new Date().toISOString()}`
  };
  
  log('\nüì§ Attempting to update Org B:', 'blue');
  log(`  Organization ID: ${config.adminBOrgId}`, 'blue');
  log(`  Update: ${JSON.stringify(maliciousUpdate)}`, 'blue');
  log(`  Token: Admin A (authorized for Org A only)`, 'blue');
  
  const response = await makeRequest(`${STAGING_URL}/api/v1/admin/organizations/${config.adminBOrgId}`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${config.adminAToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(maliciousUpdate)
  });
  
  log(`\nüì• Response: ${response.status} ${response.statusText}`, 'blue');
  log(`Data: ${JSON.stringify(response.data, null, 2)}`, 'blue');
  
  // Vulnerability check: Should get 403, but currently succeeds
  const isVulnerable = response.status === 200 && 
                       (response.data?.id === config.adminBOrgId ||
                        response.data?.organization_id === config.adminBOrgId);
  
  const result = {
    testName,
    endpoint: 'PUT /api/v1/admin/organizations/:id',
    attack: 'Admin A updates Org B settings via path parameter',
    expectedBehavior: '403 Forbidden - req.params.id should be validated',
    actualStatus: response.status,
    vulnerable: isVulnerable,
    severity: 'HIGH',
    response: response.data
  };
  
  if (isVulnerable) {
    log('\n‚ö†Ô∏è  VULNERABILITY CONFIRMED ‚ö†Ô∏è', 'red');
    log('  Admin A can modify Org B\'s settings!', 'red');
    log('  Path parameter is not validated against effectiveOrganizationId.', 'red');
    log('  This allows cross-organization sabotage.', 'red');
  } else {
    log('\n‚úÖ Protected - Request was blocked', 'green');
  }
  
  results.push(result);
  return result;
}

async function test4_UserDataAccess(config, results) {
  const testName = 'User Data Access (Cross-Organization)';
  logTest(4, 5, testName);
  
  log('\nüìã Description:', 'yellow');
  log('  Admin A attempts to read user list from Org B.');
  log('  Middleware checks req.query.organizationId (present in query).');
  log('  But Admin A can still try to access Org B users.');
  
  log('\nüì§ Requesting Org B users with Admin A token:', 'blue');
  log(`  Query: ?organizationId=${config.adminBOrgId}`, 'blue');
  log(`  Token: Admin A (authorized for Org A only)`, 'blue');
  
  const response = await getUsersByOrg(config.adminAToken, config.adminBOrgId);
  
  log(`\nüì• Response: ${response.status} ${response.statusText}`, 'blue');
  
  // Check if any users were returned
  const userData = response.data?.data || [];
  log(`Users returned: ${userData.length}`, 'blue');
  
  if (userData.length > 0) {
    log(`Sample: ${JSON.stringify(userData[0], null, 2)}`, 'blue');
  }
  
  // Vulnerability check: Should get 403 or empty list, but currently may return users
  const isVulnerable = response.status === 200 && userData.length > 0 &&
                       userData.some(u => u.organization_id === config.adminBOrgId);
  
  const result = {
    testName,
    endpoint: 'GET /api/v1/admin/users?organizationId=:id',
    attack: 'Admin A requests Org B users via query parameter',
    expectedBehavior: '403 Forbidden or empty list - query organizationId should be validated',
    actualStatus: response.status,
    vulnerable: isVulnerable,
    severity: 'MEDIUM',
    usersReturned: userData.length,
    response: response.data
  };
  
  if (isVulnerable) {
    log('\n‚ö†Ô∏è  VULNERABILITY CONFIRMED ‚ö†Ô∏è', 'red');
    log(`  Admin A can access ${userData.length} users from Org B!`, 'red');
    log('  PII disclosure: emails, names, roles exposed.', 'red');
  } else if (response.status === 403) {
    log('\n‚úÖ Protected - Request was blocked with 403', 'green');
  } else {
    log('\n‚úÖ Protected - No cross-org data returned', 'green');
  }
  
  results.push(result);
  return result;
}

async function test5_HierarchyCreation(config, results) {
  const testName = 'Hierarchy Creation (Body Parameter)';
  logTest(5, 5, testName);
  
  log('\nüìã Description:', 'yellow');
  log('  Admin A attempts to create hierarchy in Org B via body parameter.');
  log('  Middleware checks req.query.organizationId (not present).');
  log('  Endpoint uses req.body.organizationId without validation.');
  
  // Create a test hierarchy entry for Org B
  const hierarchyData = {
    organizationId: config.adminBOrgId,
    managerId: '00000000-0000-0000-0000-000000000001', // Fake IDs for testing
    employeeId: '00000000-0000-0000-0000-000000000002',
    level: 1,
    isDirectReport: true
  };
  
  log('\nüì§ Creating hierarchy in Org B:', 'blue');
  log(`  Body organizationId: ${config.adminBOrgId}`, 'blue');
  log(`  Token: Admin A (authorized for Org A only)`, 'blue');
  
  const response = await makeRequest(`${STAGING_URL}/api/v1/hierarchy`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${config.adminAToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(hierarchyData)
  });
  
  log(`\nüì• Response: ${response.status} ${response.statusText}`, 'blue');
  log(`Data: ${JSON.stringify(response.data, null, 2)}`, 'blue');
  
  // Vulnerability check: Should get 403, but currently may succeed or fail for other reasons
  const isVulnerable = response.status === 200 || 
                       (response.status === 201) ||
                       (response.data?.success === true);
  
  const result = {
    testName,
    endpoint: 'POST /api/v1/hierarchy',
    attack: 'Admin A creates hierarchy in Org B via body parameter',
    expectedBehavior: '403 Forbidden - req.body.organizationId should be validated',
    actualStatus: response.status,
    vulnerable: isVulnerable,
    severity: 'CRITICAL',
    response: response.data
  };
  
  if (isVulnerable) {
    log('\n‚ö†Ô∏è  VULNERABILITY CONFIRMED ‚ö†Ô∏è', 'red');
    log('  Admin A can create hierarchy relationships in Org B!', 'red');
    log('  Body parameter organizationId is not validated.', 'red');
  } else if (response.status === 403) {
    log('\n‚úÖ Protected - Request was blocked with 403', 'green');
  } else {
    log('\n‚ö†Ô∏è  Inconclusive - Failed for other reason (may need valid user IDs)', 'yellow');
  }
  
  results.push(result);
  return result;
}

// ============================================================================
// Main Test Execution
// ============================================================================

async function runTests(config) {
  const results = [];
  
  logSection('TENANCY VALIDATION VULNERABILITY TEST');
  log(`Target: ${STAGING_URL}`, 'cyan');
  log(`Time: ${new Date().toISOString()}`, 'cyan');
  log(`\nVulnerability: requireOrgScopedAdmin only validates req.query.organizationId`, 'yellow');
  log(`Many endpoints use organizationId from body/params/CSV without validation.`, 'yellow');
  
  // Validation phase
  try {
    await validateHealth();
    await validateToken(config.adminAToken, 'Admin A Token');
    
    log('\n‚úÖ Prerequisites validated - starting attack tests...\n', 'green');
  } catch (error) {
    log(`\n‚ùå Prerequisites failed: ${error.message}`, 'red');
    log('\nCannot proceed with tests. Please check your configuration.', 'red');
    process.exit(1);
  }
  
  // Wait before starting attacks
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Run all test cases
  await test1_HierarchyCSVUpload(config, results);
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  await test2_OrganizationAccess(config, results);
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  await test3_OrganizationUpdate(config, results);
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  await test4_UserDataAccess(config, results);
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  await test5_HierarchyCreation(config, results);
  
  // Summary
  logSection('TEST SUMMARY');
  
  const vulnerableTests = results.filter(r => r.vulnerable);
  const protectedTests = results.filter(r => !r.vulnerable);
  
  log(`\nTotal Tests: ${results.length}`, 'cyan');
  log(`Vulnerable: ${vulnerableTests.length}`, vulnerableTests.length > 0 ? 'red' : 'green');
  log(`Protected: ${protectedTests.length}`, 'green');
  
  if (vulnerableTests.length > 0) {
    log('\n‚ö†Ô∏è  CRITICAL SECURITY VULNERABILITIES CONFIRMED ‚ö†Ô∏è\n', 'red');
    log('Vulnerable Endpoints:', 'red');
    vulnerableTests.forEach(test => {
      log(`  ‚ùå [${test.severity}] ${test.testName}`, 'red');
      log(`     ${test.endpoint}`, 'red');
      log(`     ${test.attack}`, 'red');
    });
    
    log('\nüîí Root Cause:', 'yellow');
    log('  The requireOrgScopedAdmin middleware only validates organizationId from', 'yellow');
    log('  req.query.organizationId. Endpoints that use organizationId from:', 'yellow');
    log('  - req.body.organizationId', 'yellow');
    log('  - req.params.id / req.params.organizationId', 'yellow');
    log('  - CSV file content', 'yellow');
    log('  are NOT validated against the admin\'s effectiveOrganizationId.', 'yellow');
    
    log('\nüí° Recommended Fix:', 'cyan');
    log('  1. Add validation helper to middleware: req.validateOrgAccess(targetOrgId)', 'cyan');
    log('  2. Call validation in all controllers before processing', 'cyan');
    log('  3. Or use separate requireOrgAccess() middleware for path params', 'cyan');
  } else {
    log('\n‚úÖ No vulnerabilities detected - System appears to be protected\n', 'green');
  }
  
  return results;
}

// ============================================================================
// CLI Entry Point
// ============================================================================

async function main() {
  // Parse command-line arguments
  const args = process.argv.slice(2);
  
  const config = {
    adminAToken: process.env.ADMIN_A_TOKEN,
    adminAOrgId: process.env.ADMIN_A_ORG_ID,
    adminBOrgId: process.env.ADMIN_B_ORG_ID,
    adminBOrgName: process.env.ADMIN_B_ORG_NAME,
    adminBOrgSlug: process.env.ADMIN_B_ORG_SLUG
  };
  
  // Parse command-line arguments
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--admin-a-token' && args[i + 1]) {
      config.adminAToken = args[i + 1];
      i++;
    } else if (args[i] === '--admin-a-org-id' && args[i + 1]) {
      config.adminAOrgId = args[i + 1];
      i++;
    } else if (args[i] === '--admin-b-org-id' && args[i + 1]) {
      config.adminBOrgId = args[i + 1];
      i++;
    } else if (args[i] === '--admin-b-org-name' && args[i + 1]) {
      config.adminBOrgName = args[i + 1];
      i++;
    } else if (args[i] === '--admin-b-org-slug' && args[i + 1]) {
      config.adminBOrgSlug = args[i + 1];
      i++;
    }
  }
  
  // Validate required parameters
  const missing = [];
  if (!config.adminAToken) missing.push('ADMIN_A_TOKEN or --admin-a-token');
  if (!config.adminBOrgId) missing.push('ADMIN_B_ORG_ID or --admin-b-org-id');
  if (!config.adminBOrgName) missing.push('ADMIN_B_ORG_NAME or --admin-b-org-name');
  if (!config.adminBOrgSlug) missing.push('ADMIN_B_ORG_SLUG or --admin-b-org-slug');
  
  if (missing.length > 0) {
    log('\n‚ùå ERROR: Missing required parameters\n', 'red');
    log('Missing:', 'yellow');
    missing.forEach(param => log(`  - ${param}`, 'yellow'));
    
    log('\nUsage:', 'cyan');
    log('  node test-tenancy-vulnerability.js \\', 'cyan');
    log('    --admin-a-token "eyJhbG..." \\', 'cyan');
    log('    --admin-b-org-id "uuid-of-org-b" \\', 'cyan');
    log('    --admin-b-org-name "Company B" \\', 'cyan');
    log('    --admin-b-org-slug "company-b"', 'cyan');
    
    log('\nOr use environment variables:', 'cyan');
    log('  ADMIN_A_TOKEN="..." \\', 'cyan');
    log('  ADMIN_B_ORG_ID="..." \\', 'cyan');
    log('  ADMIN_B_ORG_NAME="..." \\', 'cyan');
    log('  ADMIN_B_ORG_SLUG="..." \\', 'cyan');
    log('  node test-tenancy-vulnerability.js', 'cyan');
    
    log('\nHow to get these values:', 'yellow');
    log('  1. Login to staging as Admin A: https://feedbackflow-frontend-staging.onrender.com', 'yellow');
    log('  2. Open DevTools > Application > Cookies', 'yellow');
    log('  3. Copy the "token" cookie value (Admin A Token)', 'yellow');
    log('  4. Go to Administration > Organizations to find Org IDs, names, and slugs', 'yellow');
    log('  5. You need info for a DIFFERENT organization (Org B) that Admin A should NOT access', 'yellow');
    
    process.exit(1);
  }
  
  log('\nüîê Configuration:', 'cyan');
  log(`  Admin A Token: ${config.adminAToken.substring(0, 30)}...`, 'cyan');
  log(`  Target Org B ID: ${config.adminBOrgId}`, 'cyan');
  log(`  Target Org B Name: ${config.adminBOrgName}`, 'cyan');
  log(`  Target Org B Slug: ${config.adminBOrgSlug}`, 'cyan');
  
  try {
    const results = await runTests(config);
    
    // Save results to JSON file
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `tenancy-vulnerability-test-${timestamp}.json`;
    
    const report = {
      timestamp: new Date().toISOString(),
      environment: 'staging',
      url: STAGING_URL,
      vulnerability: 'Improper Tenancy Validation in requireOrgScopedAdmin',
      config: {
        adminAOrgId: config.adminAOrgId,
        targetOrgId: config.adminBOrgId,
        targetOrgName: config.adminBOrgName,
        targetOrgSlug: config.adminBOrgSlug
      },
      summary: {
        totalTests: results.length,
        vulnerable: results.filter(r => r.vulnerable).length,
        protected: results.filter(r => !r.vulnerable).length
      },
      results
    };
    
    fs.writeFileSync(filename, JSON.stringify(report, null, 2));
    
    log(`\nüìÑ Report saved to: ${filename}`, 'green');
    
    // Exit with error code if vulnerabilities found
    if (results.some(r => r.vulnerable)) {
      process.exit(1);
    }
    
  } catch (error) {
    log(`\n‚ùå Test execution failed: ${error.message}`, 'red');
    console.error(error.stack);
    process.exit(1);
  }
}

// Handle global fetch (for Node.js < 18)
if (typeof fetch === 'undefined') {
  try {
    global.fetch = require('node-fetch');
  } catch (e) {
    console.error('‚ùå fetch is not available and node-fetch is not installed.');
    console.error('Please upgrade to Node.js 18+ or run: npm install node-fetch');
    process.exit(1);
  }
}

main();

