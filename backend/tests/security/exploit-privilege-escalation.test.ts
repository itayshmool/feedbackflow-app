/**
 * SECURITY EXPLOIT TEST
 * 
 * This test replicates the EXACT attack scenario reported by the security team.
 * 
 * Attack Steps (from security report):
 * 1. Admin user changes their email in the UI
 * 2. Admin calls /api/v1/admin/users/import with their original email
 * 3. Payload includes roles: ["employee", "manager", "super_admin"]
 * 4. Result: Admin gains super_admin access to all organizations
 * 
 * EXPECTED BEHAVIOR:
 * - BEFORE FIX: This test should FAIL (exploit works)
 * - AFTER FIX: This test should PASS (exploit blocked)
 */

import request from 'supertest';
import { createApp } from '../../src/app.js';
import { dbQuery } from '../../src/config/database.js';
import jwt from 'jsonwebtoken';

describe('SECURITY EXPLOIT: Privilege Escalation via User Import', () => {
  let app: any;
  let adminToken: string;
  let adminUserId: string;
  let adminOriginalEmail: string;
  let testOrgId: string;

  beforeAll(async () => {
    // Initialize app
    app = createApp();

    // Setup: Create test organization
    const orgResult = await dbQuery(
      `INSERT INTO organizations (name, slug) 
       VALUES ($1, $2) 
       RETURNING id`,
      ['Test Security Org', 'test-security-org-' + Date.now()]
    );
    testOrgId = orgResult.rows[0].id;

    // Setup: Create admin user (NOT super_admin)
    adminOriginalEmail = `test-admin-${Date.now()}@example.com`;
    
    const userResult = await dbQuery(
      `INSERT INTO users (email, name, organization_id, is_active, email_verified) 
       VALUES ($1, $2, $3, true, true) 
       RETURNING id`,
      [adminOriginalEmail, 'Test Admin', testOrgId]
    );
    adminUserId = userResult.rows[0].id;

    // Assign admin role (not super_admin)
    const adminRoleResult = await dbQuery(
      `SELECT id FROM roles WHERE name = 'admin'`
    );
    const adminRoleId = adminRoleResult.rows[0].id;

    await dbQuery(
      `INSERT INTO user_roles (user_id, role_id, organization_id, is_active) 
       VALUES ($1, $2, $3, true)`,
      [adminUserId, adminRoleId, testOrgId]
    );

    // Also assign employee role (typical setup)
    const employeeRoleResult = await dbQuery(
      `SELECT id FROM roles WHERE name = 'employee'`
    );
    const employeeRoleId = employeeRoleResult.rows[0].id;

    await dbQuery(
      `INSERT INTO user_roles (user_id, role_id, organization_id, is_active) 
       VALUES ($1, $2, $3, true)`,
      [adminUserId, employeeRoleId, testOrgId]
    );

    // Get admin token
    adminToken = await generateTokenForUser(adminUserId);

    // Verify admin does NOT have super_admin role initially
    const rolesCheck = await dbQuery(
      `SELECT r.name 
       FROM user_roles ur 
       JOIN roles r ON ur.role_id = r.id 
       WHERE ur.user_id = $1 AND ur.is_active = true`,
      [adminUserId]
    );
    const initialRoles = rolesCheck.rows.map((r: any) => r.name);
    expect(initialRoles).toContain('admin');
    expect(initialRoles).toContain('employee');
    expect(initialRoles).not.toContain('super_admin');
    
    console.log(`\nâœ“ Test setup complete:`);
    console.log(`  - Organization: ${testOrgId}`);
    console.log(`  - Admin user: ${adminOriginalEmail}`);
    console.log(`  - Admin roles: [${initialRoles.join(', ')}]`);
  });

  afterAll(async () => {
    // Cleanup
    try {
      await dbQuery(`DELETE FROM user_roles WHERE user_id = $1`, [adminUserId]);
      await dbQuery(`DELETE FROM users WHERE id = $1`, [adminUserId]);
      await dbQuery(`DELETE FROM organizations WHERE id = $1`, [testOrgId]);
      
      // Clean up any users created during the exploit test
      await dbQuery(`DELETE FROM users WHERE email = $1`, [adminOriginalEmail]);
    } catch (error) {
      console.error('Cleanup error:', error);
    }
  });

  /**
   * EXACT REPLICATION OF SECURITY TEAM'S ATTACK
   */
  it('EXPLOIT TEST: Admin escalates to super_admin via user import', async () => {
    console.log('\nðŸ”´ RUNNING EXPLOIT TEST (EXACT ATTACK SCENARIO)\n');

    // STEP 1: Admin updates their email (simulating UI action)
    const fakeEmail = `fake-${Date.now()}@wix.com`;
    
    await dbQuery(
      `UPDATE users SET email = $1 WHERE id = $2`,
      [fakeEmail, adminUserId]
    );
    
    console.log(`âœ“ Step 1: Changed admin email from ${adminOriginalEmail} to ${fakeEmail}`);

    // STEP 2: Get current roles before attack
    const rolesBeforeAttack = await dbQuery(
      `SELECT r.name 
       FROM user_roles ur 
       JOIN roles r ON ur.role_id = r.id 
       WHERE ur.user_id = $1 AND ur.is_active = true`,
      [adminUserId]
    );
    const rolesBefore = rolesBeforeAttack.rows.map((r: any) => r.name);
    console.log(`âœ“ Step 2: Current roles: [${rolesBefore.join(', ')}]`);

    // STEP 3: Execute the attack (EXACT payload from security report)
    console.log(`\nðŸš¨ EXECUTING ATTACK: Importing user with original email and super_admin role\n`);
    
    const attackPayload = {
      users: [{
        email: adminOriginalEmail,  // âš ï¸ Using ORIGINAL email
        name: "asdaseraaasdasdn",    // âš ï¸ Random name from security report
        organizationId: testOrgId,
        department: "Security",
        position: "super_admin",
        roles: ["employee", "manager", "super_admin"]  // ðŸ”´ PRIVILEGE ESCALATION
      }]
    };

    const response = await request(app)
      .post('/api/v1/admin/users/import')
      .set('Authorization', `Bearer ${adminToken}`)
      .set('Content-Type', 'application/json')
      .send(attackPayload);

    console.log(`Response status: ${response.status}`);
    console.log(`Response body:`, JSON.stringify(response.body, null, 2));

    // STEP 4: Check if exploit worked (user was created/updated with super_admin)
    const newUserCheck = await dbQuery(
      `SELECT id FROM users WHERE email = $1`,
      [adminOriginalEmail]
    );

    if (newUserCheck.rows.length > 0) {
      const exploitUserId = newUserCheck.rows[0].id;
      
      const rolesAfterAttack = await dbQuery(
        `SELECT r.name 
         FROM user_roles ur 
         JOIN roles r ON ur.role_id = r.id 
         WHERE ur.user_id = $1 AND ur.is_active = true`,
        [exploitUserId]
      );
      const rolesAfter = rolesAfterAttack.rows.map((r: any) => r.name);
      
      console.log(`\nðŸ“Š ATTACK RESULT:`);
      console.log(`   Created user ID: ${exploitUserId}`);
      console.log(`   Roles granted: [${rolesAfter.join(', ')}]`);

      // VULNERABILITY CHECK
      if (rolesAfter.includes('super_admin')) {
        console.log(`\nðŸ”´ EXPLOIT SUCCESSFUL! User gained super_admin privileges!`);
        console.log(`   âš ï¸  This is a CRITICAL SECURITY VULNERABILITY\n`);
        
        // Test should FAIL before fix (vulnerability exists)
        throw new Error(
          'SECURITY VULNERABILITY CONFIRMED: Admin successfully escalated to super_admin role. ' +
          'This exploit must be blocked!'
        );
      } else {
        console.log(`\nâœ… EXPLOIT BLOCKED! super_admin role was not granted\n`);
      }
    } else {
      console.log(`\nâœ… EXPLOIT BLOCKED! User creation was rejected\n`);
    }

    // After fix, we expect:
    // - Response indicates error/partial success
    // - super_admin role NOT granted
    // - Clear error message about privilege escalation
    expect(response.body.data.totalErrors).toBeGreaterThan(0);
    expect(response.body.data.errors[0].error).toMatch(/privilege escalation denied/i);
  }, 30000); // 30 second timeout

  /**
   * ADDITIONAL ATTACK VECTOR: Bulk role assignment
   */
  it('EXPLOIT TEST: Admin escalates to super_admin via bulk assignment', async () => {
    console.log('\nðŸ”´ TESTING ATTACK VECTOR 2: Bulk Role Assignment\n');

    // Create a victim user
    const victimEmail = `victim-${Date.now()}@example.com`;
    const victimResult = await dbQuery(
      `INSERT INTO users (email, name, organization_id, is_active, email_verified) 
       VALUES ($1, $2, $3, true, true) 
       RETURNING id`,
      [victimEmail, 'Victim User', testOrgId]
    );
    const victimUserId = victimResult.rows[0].id;

    // Get super_admin role ID
    const superAdminRoleResult = await dbQuery(
      `SELECT id FROM roles WHERE name = 'super_admin'`
    );
    const superAdminRoleId = superAdminRoleResult.rows[0].id;

    // Attack: Admin tries to bulk-assign super_admin role
    const response = await request(app)
      .post('/api/v1/admin/users/bulk')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        operation: 'assign_role',
        userIds: [victimUserId],
        roleId: superAdminRoleId
      });

    console.log(`Response status: ${response.status}`);
    console.log(`Response body:`, JSON.stringify(response.body, null, 2));

    // Check if role was assigned
    const rolesCheck = await dbQuery(
      `SELECT r.name 
       FROM user_roles ur 
       JOIN roles r ON ur.role_id = r.id 
       WHERE ur.user_id = $1 AND ur.is_active = true`,
      [victimUserId]
    );
    const assignedRoles = rolesCheck.rows.map((r: any) => r.name);

    if (assignedRoles.includes('super_admin')) {
      console.log(`\nðŸ”´ EXPLOIT SUCCESSFUL! Victim gained super_admin via bulk assignment!\n`);
      throw new Error('SECURITY VULNERABILITY: Bulk role assignment allows privilege escalation');
    } else {
      console.log(`\nâœ… EXPLOIT BLOCKED! super_admin was not assigned via bulk operation\n`);
    }

    // Cleanup
    await dbQuery(`DELETE FROM user_roles WHERE user_id = $1`, [victimUserId]);
    await dbQuery(`DELETE FROM users WHERE id = $1`, [victimUserId]);

    // After fix, expect rejection
    expect(response.status).toBe(400);
    expect(response.body.details).toMatch(/privilege escalation denied/i);
  }, 30000);

  /**
   * ADDITIONAL ATTACK VECTOR: Direct role assignment
   */
  it('EXPLOIT TEST: Admin escalates to super_admin via direct role assignment', async () => {
    console.log('\nðŸ”´ TESTING ATTACK VECTOR 3: Direct Role Assignment\n');

    // Create a victim user
    const victimEmail = `victim2-${Date.now()}@example.com`;
    const victimResult = await dbQuery(
      `INSERT INTO users (email, name, organization_id, is_active, email_verified) 
       VALUES ($1, $2, $3, true, true) 
       RETURNING id`,
      [victimEmail, 'Victim User 2', testOrgId]
    );
    const victimUserId = victimResult.rows[0].id;

    // Get super_admin role ID
    const superAdminRoleResult = await dbQuery(
      `SELECT id FROM roles WHERE name = 'super_admin'`
    );
    const superAdminRoleId = superAdminRoleResult.rows[0].id;

    // Attack: Admin tries to directly assign super_admin role
    const response = await request(app)
      .post(`/api/v1/admin/users/${victimUserId}/roles`)
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        roleId: superAdminRoleId
      });

    console.log(`Response status: ${response.status}`);
    console.log(`Response body:`, JSON.stringify(response.body, null, 2));

    // Check if role was assigned
    const rolesCheck = await dbQuery(
      `SELECT r.name 
       FROM user_roles ur 
       JOIN roles r ON ur.role_id = r.id 
       WHERE ur.user_id = $1 AND ur.is_active = true`,
      [victimUserId]
    );
    const assignedRoles = rolesCheck.rows.map((r: any) => r.name);

    if (assignedRoles.includes('super_admin')) {
      console.log(`\nðŸ”´ EXPLOIT SUCCESSFUL! Victim gained super_admin via direct assignment!\n`);
      throw new Error('SECURITY VULNERABILITY: Direct role assignment allows privilege escalation');
    } else {
      console.log(`\nâœ… EXPLOIT BLOCKED! super_admin was not assigned directly\n`);
    }

    // Cleanup
    await dbQuery(`DELETE FROM user_roles WHERE user_id = $1`, [victimUserId]);
    await dbQuery(`DELETE FROM users WHERE id = $1`, [victimUserId]);

    // After fix, expect rejection
    expect(response.status).toBe(400);
    expect(response.body.details).toMatch(/privilege escalation denied/i);
  }, 30000);
});

// Helper function to generate JWT token for testing
async function generateTokenForUser(userId: string): Promise<string> {
  const JWT_SECRET = process.env.JWT_SECRET || 'test-secret-key-feedbackflow-2024';
  
  const user = await dbQuery(
    `SELECT u.id, u.email, u.name, u.organization_id,
            COALESCE(ARRAY_AGG(DISTINCT r.name) FILTER (WHERE r.name IS NOT NULL), ARRAY[]::text[]) as roles,
            COALESCE(
              ARRAY_AGG(
                DISTINCT jsonb_build_object(
                  'id', o.id,
                  'name', o.name,
                  'slug', o.slug
                )
              ) FILTER (WHERE o.id IS NOT NULL AND ur2.role_id = (SELECT id FROM roles WHERE name = 'admin')),
              ARRAY[]::jsonb[]
            ) as admin_organizations
     FROM users u
     LEFT JOIN user_roles ur ON u.id = ur.user_id AND ur.is_active = true
     LEFT JOIN roles r ON ur.role_id = r.id
     LEFT JOIN user_roles ur2 ON u.id = ur2.user_id AND ur2.is_active = true
     LEFT JOIN organizations o ON ur2.organization_id = o.id
     WHERE u.id = $1
     GROUP BY u.id`,
    [userId]
  );

  const userData = user.rows[0];
  
  const payload = {
    id: userData.id,
    email: userData.email,
    name: userData.name,
    roles: userData.roles || [],
    organizationId: userData.organization_id,
    adminOrganizations: userData.admin_organizations || []
  };

  return jwt.sign(payload, JWT_SECRET, { expiresIn: '1h' });
}

